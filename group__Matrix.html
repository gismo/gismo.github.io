<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<title>G+Smo: Matrix module</title>
<link href="gismodoxy_tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://people.ricam.oeaw.ac.at/gismo/mj/MathJax.js"></script>
<link href="doxygen.css"   rel="stylesheet" type="text/css" />
<link href="gismodoxy.css" rel="stylesheet" type="text/css">
<!--  -->
<!-- <script type="text/javascript"> -->
<!-- </script> -->
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- <a name="top"></a> -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="gslogo-doxy.jpg"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname"><a href="index.html"><font style="font-variant:small-caps;">G+S</font><font style="font-variant:small-caps;"
															    color="#000000">mo</font></a>
   &#160;<span id="projectnumber">25.01.0</span>
   </div>
   <div id="projectbrief">Geometry + Simulation Modules</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__Matrix.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle"><div class="title">Matrix module<div class="ingroups"><a class="el" href="group__Modules.html">The G+Smo modules</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<pre class="fragment">This module provides dense and sparse matrix data structures. It
is based on the &lt;a href="http://eigen.tuxfamily.org"
target="_blank"&gt;Eigen&lt;/a&gt; library and ports all the linear algebra
related infrastructure to G+Smo. The main objects are gsMatrix
for dense matrices, gsVector for dense vectors, gsSparseMatrix for
sparse matrices and gsSparseVector for sparse vectors. Typical
matrix decompositions such as LU, QR, SVD, and so on, are
available.  Furthermore, the user has also access to iterative
solvers like conjugate gradient methods with different
preconditioners. Finally, one can use popular high-end linear
solver packages like PARADISO and SuperLU through a common
interface.

&lt;a href="http://eigen.tuxfamily.org/dox" target="_blank"&gt;Eigen Documentation&lt;/a&gt;
</pre><h1><a class="anchor" id="matop"></a>
Main matrix operations</h1>
<div class="fragment"><div class="line"><span class="comment">// A simple quickref for Eigen. Add anything that&#39;s missing.</span></div>
<div class="line"><span class="comment">// Main author: Keir Mierle</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;Eigen/Dense&gt;</span></div>
<div class="line"> </div>
<div class="line">gsMatrix&lt;double, 3, 3&gt; A;               <span class="comment">// Fixed rows and cols. Same as Matrix3d.</span></div>
<div class="line">Matrix&lt;double, 3, Dynamic&gt; B;         <span class="comment">// Fixed rows, dynamic cols.</span></div>
<div class="line">Matrix&lt;double, Dynamic, Dynamic&gt; C;   <span class="comment">// Full dynamic. Same as MatrixXd.</span></div>
<div class="line">Matrix&lt;double, 3, 3, RowMajor&gt; E;     <span class="comment">// Row major; default is column-major.</span></div>
<div class="line">Matrix3f P, Q, R;                     <span class="comment">// 3x3 float matrix.</span></div>
<div class="line">Vector3f x, y, z;                     <span class="comment">// 3x1 float matrix.</span></div>
<div class="line">RowVector3f a, b, c;                  <span class="comment">// 1x3 float matrix.</span></div>
<div class="line">VectorXd v;                           <span class="comment">// Dynamic column vector of doubles</span></div>
<div class="line"><span class="keywordtype">double</span> s;                            </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Basic usage</span></div>
<div class="line"><span class="comment">// Eigen          // Matlab           // comments</span></div>
<div class="line">x.size()          <span class="comment">// length(x)        // vector size</span></div>
<div class="line">C.rows()          <span class="comment">// size(C,1)        // number of rows</span></div>
<div class="line">C.cols()          <span class="comment">// size(C,2)        // number of columns</span></div>
<div class="line">x(i)              <span class="comment">// x(i+1)           // Matlab is 1-based</span></div>
<div class="line">C(i,j)            <span class="comment">// C(i+1,j+1)       //</span></div>
<div class="line"> </div>
<div class="line">A.resize(4, 4);   <span class="comment">// Runtime error if assertions are on.</span></div>
<div class="line">B.resize(4, 9);   <span class="comment">// Runtime error if assertions are on.</span></div>
<div class="line">A.resize(3, 3);   <span class="comment">// Ok; size didn&#39;t change.</span></div>
<div class="line">B.resize(3, 9);   <span class="comment">// Ok; only dynamic cols changed.</span></div>
<div class="line">                  </div>
<div class="line">A &lt;&lt; 1, 2, 3,     <span class="comment">// Initialize A. The elements can also be</span></div>
<div class="line">     4, 5, 6,     <span class="comment">// matrices, which are stacked along cols</span></div>
<div class="line">     7, 8, 9;     <span class="comment">// and then the rows are stacked.</span></div>
<div class="line">B &lt;&lt; A, A, A;     <span class="comment">// B is three horizontally stacked A&#39;s.</span></div>
<div class="line">A.fill(10);       <span class="comment">// Fill A with all 10&#39;s.</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Eigen                            // Matlab</span></div>
<div class="line">MatrixXd::Identity(rows,cols)       <span class="comment">// eye(rows,cols)</span></div>
<div class="line">C.setIdentity(rows,cols)            <span class="comment">// C = eye(rows,cols)</span></div>
<div class="line">MatrixXd::Zero(rows,cols)           <span class="comment">// zeros(rows,cols)</span></div>
<div class="line">C.setZero(rows,cols)                <span class="comment">// C = ones(rows,cols)</span></div>
<div class="line">MatrixXd::Ones(rows,cols)           <span class="comment">// ones(rows,cols)</span></div>
<div class="line">C.setOnes(rows,cols)                <span class="comment">// C = ones(rows,cols)</span></div>
<div class="line">MatrixXd::Random(rows,cols)         <span class="comment">// rand(rows,cols)*2-1        // MatrixXd::Random returns uniform random numbers in (-1, 1).</span></div>
<div class="line">C.setRandom(rows,cols)              <span class="comment">// C = rand(rows,cols)*2-1</span></div>
<div class="line">VectorXd::LinSpaced(size,low,high)   <span class="comment">// linspace(low,high,size)&#39;</span></div>
<div class="line">v.setLinSpaced(size,low,high)        <span class="comment">// v = linspace(low,high,size)&#39;</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Matrix slicing and blocks. All expressions listed here are read/write.</span></div>
<div class="line"><span class="comment">// Templated size versions are faster. Note that Matlab is 1-based (a size N</span></div>
<div class="line"><span class="comment">// vector is x(1)...x(N)).</span></div>
<div class="line"><span class="comment">// Eigen                           // Matlab</span></div>
<div class="line">x.head(n)                          <span class="comment">// x(1:n)</span></div>
<div class="line">x.head&lt;n&gt;()                        <span class="comment">// x(1:n)</span></div>
<div class="line">x.tail(n)                          <span class="comment">// x(end - n + 1: end)</span></div>
<div class="line">x.tail&lt;n&gt;()                        <span class="comment">// x(end - n + 1: end)</span></div>
<div class="line">x.segment(i, n)                    <span class="comment">// x(i+1 : i+n)</span></div>
<div class="line">x.segment&lt;n&gt;(i)                    <span class="comment">// x(i+1 : i+n)</span></div>
<div class="line">P.block(i, j, rows, cols)          <span class="comment">// P(i+1 : i+rows, j+1 : j+cols)</span></div>
<div class="line">P.block&lt;rows, cols&gt;(i, j)          <span class="comment">// P(i+1 : i+rows, j+1 : j+cols)</span></div>
<div class="line">P.row(i)                           <span class="comment">// P(i+1, :)</span></div>
<div class="line">P.col(j)                           <span class="comment">// P(:, j+1)</span></div>
<div class="line">P.leftCols&lt;cols&gt;()                 <span class="comment">// P(:, 1:cols)</span></div>
<div class="line">P.leftCols(cols)                   <span class="comment">// P(:, 1:cols)</span></div>
<div class="line">P.middleCols&lt;cols&gt;(j)              <span class="comment">// P(:, j+1:j+cols)</span></div>
<div class="line">P.middleCols(j, cols)              <span class="comment">// P(:, j+1:j+cols)</span></div>
<div class="line">P.rightCols&lt;cols&gt;()                <span class="comment">// P(:, end-cols+1:end)</span></div>
<div class="line">P.rightCols(cols)                  <span class="comment">// P(:, end-cols+1:end)</span></div>
<div class="line">P.topRows&lt;rows&gt;()                  <span class="comment">// P(1:rows, :)</span></div>
<div class="line">P.topRows(rows)                    <span class="comment">// P(1:rows, :)</span></div>
<div class="line">P.middleRows&lt;rows&gt;(i)              <span class="comment">// P(i+1:i+rows, :)</span></div>
<div class="line">P.middleRows(i, rows)              <span class="comment">// P(i+1:i+rows, :)</span></div>
<div class="line">P.bottomRows&lt;rows&gt;()               <span class="comment">// P(end-rows+1:end, :)</span></div>
<div class="line">P.bottomRows(rows)                 <span class="comment">// P(end-rows+1:end, :)</span></div>
<div class="line">P.topLeftCorner(rows, cols)        <span class="comment">// P(1:rows, 1:cols)</span></div>
<div class="line">P.topRightCorner(rows, cols)       <span class="comment">// P(1:rows, end-cols+1:end)</span></div>
<div class="line">P.bottomLeftCorner(rows, cols)     <span class="comment">// P(end-rows+1:end, 1:cols)</span></div>
<div class="line">P.bottomRightCorner(rows, cols)    <span class="comment">// P(end-rows+1:end, end-cols+1:end)</span></div>
<div class="line">P.topLeftCorner&lt;rows,cols&gt;()       <span class="comment">// P(1:rows, 1:cols)</span></div>
<div class="line">P.topRightCorner&lt;rows,cols&gt;()      <span class="comment">// P(1:rows, end-cols+1:end)</span></div>
<div class="line">P.bottomLeftCorner&lt;rows,cols&gt;()    <span class="comment">// P(end-rows+1:end, 1:cols)</span></div>
<div class="line">P.bottomRightCorner&lt;rows,cols&gt;()   <span class="comment">// P(end-rows+1:end, end-cols+1:end)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Of particular note is Eigen&#39;s swap function which is highly optimized.</span></div>
<div class="line"><span class="comment">// Eigen                           // Matlab</span></div>
<div class="line">R.row(i) = P.col(j);               <span class="comment">// R(i, :) = P(:, i)</span></div>
<div class="line">R.col(j1).swap(mat1.col(j2));      <span class="comment">// R(:, [j1 j2]) = R(:, [j2, j1])</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Views, transpose, etc; all read-write except for .adjoint().</span></div>
<div class="line"><span class="comment">// Eigen                           // Matlab</span></div>
<div class="line">R.adjoint()                        <span class="comment">// R&#39;</span></div>
<div class="line">R.transpose()                      <span class="comment">// R.&#39; or conj(R&#39;)</span></div>
<div class="line">R.diagonal()                       <span class="comment">// diag(R)</span></div>
<div class="line">x.asDiagonal()                     <span class="comment">// diag(x)</span></div>
<div class="line">R.transpose().colwise().reverse(); <span class="comment">// rot90(R)</span></div>
<div class="line">R.conjugate()                      <span class="comment">// conj(R)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// All the same as Matlab, but matlab doesn&#39;t have *= style operators.</span></div>
<div class="line"><span class="comment">// Matrix-vector.  Matrix-matrix.   Matrix-scalar.</span></div>
<div class="line">y  = M*x;          R  = P*Q;        R  = P*s;</div>
<div class="line">a  = b*M;          R  = P - Q;      R  = s*P;</div>
<div class="line">a *= M;            R  = P + Q;      R  = P/s;</div>
<div class="line">                   R *= Q;          R  = s*P;</div>
<div class="line">                   R += Q;          R *= s;</div>
<div class="line">                   R -= Q;          R /= s;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Vectorized operations on each element independently</span></div>
<div class="line"><span class="comment">// Eigen                  // Matlab</span></div>
<div class="line">R = P.cwiseProduct(Q);    <span class="comment">// R = P .* Q</span></div>
<div class="line">R = P.array() * s.array();<span class="comment">// R = P .* s</span></div>
<div class="line">R = P.cwiseQuotient(Q);   <span class="comment">// R = P ./ Q</span></div>
<div class="line">R = P.array() / Q.array();<span class="comment">// R = P ./ Q</span></div>
<div class="line">R = P.array() + s.array();<span class="comment">// R = P + s</span></div>
<div class="line">R = P.array() - s.array();<span class="comment">// R = P - s</span></div>
<div class="line">R.array() += s;           <span class="comment">// R = R + s</span></div>
<div class="line">R.array() -= s;           <span class="comment">// R = R - s</span></div>
<div class="line">R.array() &lt; Q.array();    <span class="comment">// R &lt; Q</span></div>
<div class="line">R.array() &lt;= Q.array();   <span class="comment">// R &lt;= Q</span></div>
<div class="line">R.cwiseInverse();         <span class="comment">// 1 ./ P</span></div>
<div class="line">R.array().inverse();      <span class="comment">// 1 ./ P</span></div>
<div class="line">R.array().sin()           <span class="comment">// sin(P)</span></div>
<div class="line">R.array().cos()           <span class="comment">// cos(P)</span></div>
<div class="line">R.array().pow(s)          <span class="comment">// P .^ s</span></div>
<div class="line">R.array().square()        <span class="comment">// P .^ 2</span></div>
<div class="line">R.array().cube()          <span class="comment">// P .^ 3</span></div>
<div class="line">R.cwiseSqrt()             <span class="comment">// sqrt(P)</span></div>
<div class="line">R.array().sqrt()          <span class="comment">// sqrt(P)</span></div>
<div class="line">R.array().exp()           <span class="comment">// exp(P)</span></div>
<div class="line">R.array().log()           <span class="comment">// log(P)</span></div>
<div class="line">R.cwiseMax(P)             <span class="comment">// max(R, P)</span></div>
<div class="line">R.array().max(P.array())  <span class="comment">// max(R, P)</span></div>
<div class="line">R.cwiseMin(P)             <span class="comment">// min(R, P)</span></div>
<div class="line">R.array().min(P.array())  <span class="comment">// min(R, P)</span></div>
<div class="line">R.cwiseAbs()              <span class="comment">// abs(P)</span></div>
<div class="line">R.array().abs()           <span class="comment">// abs(P)</span></div>
<div class="line">R.cwiseAbs2()             <span class="comment">// abs(P.^2)</span></div>
<div class="line">R.array().abs2()          <span class="comment">// abs(P.^2)</span></div>
<div class="line">(R.array() &lt; s).select(P,Q);  <span class="comment">// (R &lt; s ? P : Q)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Reductions.</span></div>
<div class="line"><span class="keywordtype">int</span> r, c;</div>
<div class="line"><span class="comment">// Eigen                  // Matlab</span></div>
<div class="line">R.minCoeff()              <span class="comment">// min(R(:))</span></div>
<div class="line">R.maxCoeff()              <span class="comment">// max(R(:))</span></div>
<div class="line">s = R.minCoeff(&amp;r, &amp;c)    <span class="comment">// [s, i] = min(R(:)); [r, c] = ind2sub(size(R), i);</span></div>
<div class="line">s = R.maxCoeff(&amp;r, &amp;c)    <span class="comment">// [s, i] = max(R(:)); [r, c] = ind2sub(size(R), i);</span></div>
<div class="line">R.sum()                   <span class="comment">// sum(R(:))</span></div>
<div class="line">R.colwise().sum()         <span class="comment">// sum(R)</span></div>
<div class="line">R.rowwise().sum()         <span class="comment">// sum(R, 2) or sum(R&#39;)&#39;</span></div>
<div class="line">R.prod()                  <span class="comment">// prod(R(:))</span></div>
<div class="line">R.colwise().prod()        <span class="comment">// prod(R)</span></div>
<div class="line">R.rowwise().prod()        <span class="comment">// prod(R, 2) or prod(R&#39;)&#39;</span></div>
<div class="line">R.trace()                 <span class="comment">// trace(R)</span></div>
<div class="line">R.all()                   <span class="comment">// all(R(:))</span></div>
<div class="line">R.colwise().all()         <span class="comment">// all(R)</span></div>
<div class="line">R.rowwise().all()         <span class="comment">// all(R, 2)</span></div>
<div class="line">R.any()                   <span class="comment">// any(R(:))</span></div>
<div class="line">R.colwise().any()         <span class="comment">// any(R)</span></div>
<div class="line">R.rowwise().any()         <span class="comment">// any(R, 2)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Dot products, norms, etc.</span></div>
<div class="line"><span class="comment">// Eigen                  // Matlab</span></div>
<div class="line">x.norm()                  <span class="comment">// norm(x).    Note that norm(R) doesn&#39;t work in Eigen.</span></div>
<div class="line">x.squaredNorm()           <span class="comment">// dot(x, x)   Note the equivalence is not true for complex</span></div>
<div class="line">x.dot(y)                  <span class="comment">// dot(x, y)</span></div>
<div class="line">x.cross(y)                <span class="comment">// cross(x, y) Requires #include &lt;Eigen/Geometry&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Eigen                           // Matlab</span></div>
<div class="line">A.cast&lt;<span class="keywordtype">double</span>&gt;();                  <span class="comment">// double(A)</span></div>
<div class="line">A.cast&lt;<span class="keywordtype">float</span>&gt;();                   <span class="comment">// single(A)</span></div>
<div class="line">A.cast&lt;<span class="keywordtype">int</span>&gt;();                     <span class="comment">// int32(A)</span></div>
<div class="line">A.real();                          <span class="comment">// real(A)</span></div>
<div class="line">A.imag();                          <span class="comment">// imag(A)</span></div>
<div class="line"><span class="comment">// if the original type equals destination type, no work is done</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Note that for most operations Eigen requires all operands to have the same type:</span></div>
<div class="line">MatrixXf F = MatrixXf::Zero(3,3);</div>
<div class="line">A += F;                <span class="comment">// illegal in Eigen. In Matlab A = A+F is allowed</span></div>
<div class="line">A += F.cast&lt;<span class="keywordtype">double</span>&gt;(); <span class="comment">// F converted to double and then added (generally, conversion happens on-the-fly)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Eigen can map existing memory into Eigen matrices.</span></div>
<div class="line"><span class="keywordtype">float</span> array[3];</div>
<div class="line">Vector3f::Map(array).fill(10);            <span class="comment">// create a temporary Map over array and sets entries to 10</span></div>
<div class="line"><span class="keywordtype">int</span> data[4] = {1, 2, 3, 4};</div>
<div class="line">Matrix2i mat2x2(data);                    <span class="comment">// copies data into mat2x2</span></div>
<div class="line">Matrix2i::Map(data) = 2*mat2x2;           <span class="comment">// overwrite elements of data with 2*mat2x2</span></div>
<div class="line">MatrixXi::Map(data, 2, 2) += mat2x2;      <span class="comment">// adds mat2x2 to elements of data (alternative syntax if size is not know at compile time)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Solve Ax = b. Result stored in x. Matlab: x = A \ b.</span></div>
<div class="line">x = A.ldlt().solve(b));  <span class="comment">// A sym. p.s.d.    #include &lt;Eigen/Cholesky&gt;</span></div>
<div class="line">x = A.llt() .solve(b));  <span class="comment">// A sym. p.d.      #include &lt;Eigen/Cholesky&gt;</span></div>
<div class="line">x = A.lu()  .solve(b));  <span class="comment">// Stable and fast. #include &lt;Eigen/LU&gt;</span></div>
<div class="line">x = A.qr()  .solve(b));  <span class="comment">// No pivoting.     #include &lt;Eigen/QR&gt;</span></div>
<div class="line">x = A.svd() .solve(b));  <span class="comment">// Stable, slowest. #include &lt;Eigen/SVD&gt;</span></div>
<div class="line"><span class="comment">// .ldlt() -&gt; .matrixL() and .matrixD()</span></div>
<div class="line"><span class="comment">// .llt()  -&gt; .matrixL()</span></div>
<div class="line"><span class="comment">// .lu()   -&gt; .matrixL() and .matrixU()</span></div>
<div class="line"><span class="comment">// .qr()   -&gt; .matrixQ() and .matrixR()</span></div>
<div class="line"><span class="comment">// .svd()  -&gt; .matrixU(), .singularValues(), and .matrixV()</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Eigenvalue problems</span></div>
<div class="line"><span class="comment">// Eigen                          // Matlab</span></div>
<div class="line">A.eigenvalues();                  <span class="comment">// eig(A);</span></div>
<div class="line">EigenSolver&lt;Matrix3d&gt; eig(A);     <span class="comment">// [vec val] = eig(A)</span></div>
<div class="line">eig.eigenvalues();                <span class="comment">// diag(val)</span></div>
<div class="line">eig.eigenvectors();               <span class="comment">// vec</span></div>
<div class="line"><span class="comment">// For self-adjoint matrices use SelfAdjointEigenSolver&lt;&gt;</span></div>
</div><!-- fragment --> <table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgismo_1_1gsAsConstMatrix.html">gsAsConstMatrix&lt; T, _Rows, _Cols &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a mapped object or data pointer to a const matrix without copying data.  <a href="classgismo_1_1gsAsConstMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgismo_1_1gsAsConstVector.html">gsAsConstVector&lt; T, _Rows &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a mapped object or data pointer to a const vector without copying data.  <a href="classgismo_1_1gsAsConstVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgismo_1_1gsAsMatrix.html">gsAsMatrix&lt; T, _Rows, _Cols &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a mapped object or data pointer to a matrix without copying data.  <a href="classgismo_1_1gsAsMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgismo_1_1gsAsVector.html">gsAsVector&lt; T, _Rows &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a mapped object or data pointer to a vector without copying data.  <a href="classgismo_1_1gsAsVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgismo_1_1gsMatrix.html">gsMatrix&lt; T, _Rows, _Cols, _Options &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix with arbitrary coefficient type and fixed or dynamic size.  <a href="classgismo_1_1gsMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgismo_1_1gsMatrixBlockView.html">gsMatrixBlockView&lt; MatrixType, isConst &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a block-view of the given matrix.  <a href="classgismo_1_1gsMatrixBlockView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgismo_1_1gsSparseEntries.html">gsSparseEntries&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that provides a container for triplets (i,j,value) to be filled in a sparse matrix.  <a href="classgismo_1_1gsSparseEntries.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgismo_1_1gsSparseMatrix.html">gsSparseMatrix&lt; T, _Options, _Index &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse matrix class, based on gsEigen::SparseMatrix.  <a href="classgismo_1_1gsSparseMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgismo_1_1gsSparseSolver.html">gsSparseSolver&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for solvers. The solver interface is base on 3 methods: -compute set the system matrix (possibly compute the factorization or preconditioners) -solve solves for a given right hand side -succeed returns true if solving succeded according to solver dependent criteria (usually tolerance based) So in order to solve \( A x = b \) with a solver <em>s</em> two functions must be called: s.compute(A) and s.solve(b). The calls can be chained as in s.compute(A).solve(b).  <a href="classgismo_1_1gsSparseSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgismo_1_1gsSparseVector.html">gsSparseVector&lt; T, _Options, _Index &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse vector class, based on gsEigen::SparseVector.  <a href="classgismo_1_1gsSparseVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgismo_1_1gsVector.html">gsVector&lt; T, _Rows, _Options &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector with arbitrary coefficient type and fixed or dynamic size.  <a href="classgismo_1_1gsVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgismo_1_1gsVector3d.html">gsVector3d&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fixed-size, statically allocated 3D vector.  <a href="classgismo_1_1gsVector3d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Jan 20 2025 09:35:27 for G+Smo by Doxygen v1.9.8 </li>
  </ul>
</div>
<!-- Piwik --> 
<!--
<script type="text/javascript">
var pkBaseURL = (("https:" == document.location.protocol) ? "https://stats.sylphide-consulting.com/piwik/" : "http://stats.sylphide-consulting.com/piwik/");
document.write(unescape("%3Cscript src='" + pkBaseURL + "piwik.js' type='text/javascript'%3E%3C/script%3E"));
</script><script type="text/javascript">
try {
var piwikTracker = Piwik.getTracker(pkBaseURL + "piwik.php", 20);
piwikTracker.trackPageView();
piwikTracker.enableLinkTracking();
} catch( err ) {}
</script><noscript><p><img src="http://stats.sylphide-consulting.com/piwik/piwik.php?idsite=20" style="border:0" alt="" /></p></noscript>
-->
<!-- End Piwik Tracking Code -->
</body>
</html>
