<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<title>G+Smo: Nurbs module</title>
<link href="gismodoxy_tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://people.ricam.oeaw.ac.at/gismo/mj/MathJax.js"></script>
<link href="doxygen.css"   rel="stylesheet" type="text/css" />
<link href="gismodoxy.css" rel="stylesheet" type="text/css">
<!--  -->
<!-- <script type="text/javascript"> -->
<!-- </script> -->
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- <a name="top"></a> -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="gslogo-doxy.jpg"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname"><a href="index.html"><font style="font-variant:small-caps;">G+S</font><font style="font-variant:small-caps;"
															    color="#000000">mo</font></a>
   &#160;<span id="projectnumber">25.01.0</span>
   </div>
   <div id="projectbrief">Geometry + Simulation Modules</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__Nurbs.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Nurbs module<div class="ingroups"><a class="el" href="group__Modules.html">The G+Smo modules</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This module contains the B-spline and NURBS basis functions.</p>
<p>G+Smo is very powerful in dealing with tensor-product B-splines:</p>
<div class="image">
<img src="tb1.png" alt=""/>
<div class="caption">
A tensor B-spline basis.</div></div>
<h1><a class="anchor" id="BSeval"></a>
Evaluation of B-splines</h1>
<p>There are several functions with similar names. The following table should help you in find the proper one for you.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name of procedure   </th><th class="markdownTableHeadNone">Which basis function   </th><th class="markdownTableHeadNone">Evaluate what    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>eval(u)</code>   </td><td class="markdownTableBodyNone">all active at u   </td><td class="markdownTableBodyNone">value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>evalSingle(i, u)</code>   </td><td class="markdownTableBodyNone">basis function i   </td><td class="markdownTableBodyNone">value    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>deriv(u)</code>   </td><td class="markdownTableBodyNone">all active at u   </td><td class="markdownTableBodyNone">first derivative(s)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>derivSingle(i, u)</code>   </td><td class="markdownTableBodyNone">basis function i   </td><td class="markdownTableBodyNone">first derivative(s)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>deriv2(u)</code>   </td><td class="markdownTableBodyNone">all active at u   </td><td class="markdownTableBodyNone">second derivative(s)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>deriv2Single(i, u)</code>   </td><td class="markdownTableBodyNone">basis function i   </td><td class="markdownTableBodyNone">second derivative(s)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>evalAllDers(u, k)</code>   </td><td class="markdownTableBodyNone">all active at u   </td><td class="markdownTableBodyNone">value and all derivatives up to order k    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>evalAllDersSingle(i,u,k)</code>   </td><td class="markdownTableBodyNone">basis function i   </td><td class="markdownTableBodyNone">value and all derivatives up to order k    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>evalDerSingle(i, u, k)</code>   </td><td class="markdownTableBodyNone">basis function i   </td><td class="markdownTableBodyNone">k-th derivative (k=0, ... , p-1)   </td></tr>
</table>
<p>Here <code>u</code> is a matrix of values, and every column corresponds to one evaluation point.</p>
<p>All the above functions return a unique pointer. Also, for each of these functions there is a variant suffixed with <code>_into</code>, for example <code>eval_into</code>, <code>deriv2Single_into</code>, and so on, that returns <code>void</code>, takes an additional matrix <code>result</code> as argument, and writes the result in that matrix.</p>
<p>One of the lovely things about G+Smo is that it in works nicely in arbitrary dimension and the functions look virtually the same. So if you work with a tensor-product basis, your matrix <code>u</code> has to have exactly as many rows as the number of variables and then it is used the same way as in the univariate case.</p>
<p>The price you pay for arbitrary dimension is that the results are returned in a somehow magical manner. That is, every column of <code>result</code> then contains values of <b>active functions</b> in ascending order. Thus it is usually used together with <code>active_into</code>. See the following example.</p>
<h2><a class="anchor" id="EvExample"></a>
Example of evaluation</h2>
<p>We create a bivariate quadratic tensor-product basis and evaluate the basis functions in several points. First, we need knot vectors: </p><pre class="fragment">gsKnotVector&lt;&gt; kv0(0,1,1,3); //start, end, interior knots, multiplicities of start/end knots
gsKnotVector&lt;&gt; kv1(0,1,1,3);
</pre><p> The Greville abscissae are 0, 0.25, 0.75 and 1. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000018">Todo:</a></b></dt><dd>Check these numbers; correct or update picture?</dd></dl>
<p>Then we create the basis by </p><pre class="fragment">gsTensorBSplineBasis&lt;2,double&gt; tbas (new gsBSplineBasis&lt; double &gt;(kv0), new gsBSplineBasis&lt; double &gt;(kv1));
</pre><p> Now we have 16 basis functions, the following figure shows them together with the points where we are going to evaluate them.</p>
<div class="image">
<img src="evaluation.png" alt=""/>
<div class="caption">
Mesh, numbers correspond to Greville abscissae of the basis functions, red dots to evaluation points.</div></div>
<p>We prepare six evaluation points (0,0), (0.1,0), (1,0), (0.5,0.5), (0.6,0.6), (1,1) by </p><pre class="fragment">gsMatrix&lt; double &gt; uVals(2,6);
uVals &lt;&lt; 0,0.1,1,0.5,0.6,1, 0,0,0,0.5,0.6,1;
</pre><p> and the matrices for results by </p><pre class="fragment">gsMatrix&lt; unsigned &gt; actRes;
gsMatrix&lt; double &gt; valRes;
</pre> <dl class="section note"><dt>Note</dt><dd>Note that <code>actRes</code> requires a matrix of <code>unsigned</code>, otherwise you obtain a hardly comprehensible error. This situation is good to remember in similar cases.</dd></dl>
<p>Now we ask for the evaluation and printing of the results </p><pre class="fragment">tbas.active_into(uVals,actRes);
tbas.eval_into(uVals,valRes);
std::cout &lt;&lt; "Active functions:\n" &lt;&lt; actRes &lt;&lt; "\n\nResults of evaluation:\n" &lt;&lt; valRes &lt;&lt; "\n";
</pre><p> You should obtain something like </p><pre class="fragment">Active functions:
 0  0  1  5  5  5
 1  1  2  6  6  6
 2  2  3  7  7  7
 4  4  5  9  9  9
 5  5  6 10 10 10
 6  6  7 11 11 11
 8  8  9 13 13 13
 9  9 10 14 14 14
10 10 11 15 15 15

Results of evaluation:
     1   0.64      0   0.25 0.1024      0
     0   0.34      0   0.25 0.2048      0
     0   0.02      1      0 0.0128      0
     0      0      0   0.25 0.2048      0
     0      0      0   0.25 0.4096      0
     0      0      0      0 0.0256      0
     0      0      0      0 0.0128      0
     0      0      0      0 0.0256      0
     0      0      0      0 0.0016      1
</pre><p> From the first matrix we may read that the active functions in (0,0) are functions number 0, 1, 2, 4, 5, 6, 8, 9, 10 (check with the figure). Similarly, the second column shows us the basis functions active in (0.1, 0) etc.</p>
<p>In the second matrix we see the actual values. The first column tells us that there is just one active function in (0,0) and is equal to 1 there. In (0.1, 0) we have more active functions; value of the 0th is equal to 0.64, 1th to 0.34, 2nd to 0.02 and the others are equal to zero (don't worry about that, the evaluation point is at the border of their supports). Interesting is the fourth column: we may see that in the middle of the domain there are four nonzero functions, their indices are 5, 6, 9 and 10 and all the values are equal to 0.25.</p>
<dl class="section note"><dt>Note</dt><dd>You may observe the partition of unity. The sum of all the entries in each column should be equal to one.</dd></dl>
<p>Evaluation of derivatives goes along similar lines and we invite you to play around with them in your test file. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacegismo_1_1bspline" id="r_namespacegismo_1_1bspline"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegismo_1_1bspline.html">gismo::bspline</a></td></tr>
<tr class="memdesc:namespacegismo_1_1bspline"><td class="mdescLeft">&#160;</td><td class="mdescRight">This namespace contains implementation of B-spline related algorithms. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgismo_1_1gsBSpline.html">gsBSpline&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A B-spline function of one argument, with arbitrary target dimension.  <a href="classgismo_1_1gsBSpline.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgismo_1_1gsBSplineBasis.html">gsBSplineBasis&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A univariate B-spline basis.  <a href="classgismo_1_1gsBSplineBasis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgismo_1_1gsNurbs.html">gsNurbs&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A NURBS function of one argument, with arbitrary target dimension.  <a href="classgismo_1_1gsNurbs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgismo_1_1gsNurbsBasis.html">gsNurbsBasis&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A univariate NURBS basis.  <a href="classgismo_1_1gsNurbsBasis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgismo_1_1gsNurbsCreator.html">gsNurbsCreator&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="structgismo_1_1gsNurbsCreator.html" title="Class gsNurbsCreator provides some simple examples of Nurbs Geometries.">gsNurbsCreator</a> provides some simple examples of Nurbs Geometries.  <a href="structgismo_1_1gsNurbsCreator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgismo_1_1gsPanelCreator.html">gsPanelCreator&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="structgismo_1_1gsPanelCreator.html" title="Class gsPanelCreator provides some simple examples of Nurbs Geometries.">gsPanelCreator</a> provides some simple examples of Nurbs Geometries.  <a href="structgismo_1_1gsPanelCreator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgismo_1_1gsTensorBSpline.html">gsTensorBSpline&lt; d, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tensor product of <em>d</em> B-spline functions, with arbitrary target dimension.  <a href="classgismo_1_1gsTensorBSpline.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgismo_1_1gsTensorBSplineBasis.html">gsTensorBSplineBasis&lt; d, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tensor product B-spline basis.  <a href="classgismo_1_1gsTensorBSplineBasis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgismo_1_1gsTensorBSplineBasis_3_011_00_01T_01_4.html">gsTensorBSplineBasis&lt; 1, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A univariate B-spline basis.  <a href="classgismo_1_1gsTensorBSplineBasis_3_011_00_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgismo_1_1gsTensorNurbs.html">gsTensorNurbs&lt; d, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tensor product Non-Uniform Rational B-spline function (NURBS) of parametric dimension <em>d</em>, with arbitrary target dimension.  <a href="classgismo_1_1gsTensorNurbs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgismo_1_1gsTensorNurbsBasis.html">gsTensorNurbsBasis&lt; d, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tensor product Non-Uniform Rational B-spline (NURBS) basis.  <a href="classgismo_1_1gsTensorNurbsBasis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0eaf1e5263fc56723f726f100517e78c" id="r_ga0eaf1e5263fc56723f726f100517e78c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0eaf1e5263fc56723f726f100517e78c"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Nurbs.html#ga0eaf1e5263fc56723f726f100517e78c">findHyperPlaneIntersections</a> (const <a class="el" href="classgismo_1_1gsBSpline.html">gsBSpline</a>&lt; T &gt; &amp;curve, const <a class="el" href="classgismo_1_1gsVector.html">gsVector</a>&lt; T &gt; &amp;normal, T reference, T tolerance, std::vector&lt; Root&lt; T &gt; &gt; &amp;roots)</td></tr>
<tr class="memdesc:ga0eaf1e5263fc56723f726f100517e78c"><td class="mdescLeft">&#160;</td><td class="mdescRight">find intersections of a BSpline curve with an hyperplane  <br /></td></tr>
<tr class="separator:ga0eaf1e5263fc56723f726f100517e78c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9405b094225becc7fe4f7be65d1da933" id="r_ga9405b094225becc7fe4f7be65d1da933"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Nurbs.html#ga9405b094225becc7fe4f7be65d1da933">gsBSpline</a> (T u0, T u1, unsigned interior, int <a class="el" href="classgismo_1_1gsBSpline.html#ac328e6bc87c3a072d9e3452c05370209">degree</a>, <a class="el" href="classgismo_1_1gsMatrix.html">gsMatrix</a>&lt; T &gt; <a class="el" href="classgismo_1_1gsGeometry.html#a068cc37ace6782a76b87c0b7a9da248c">coefs</a>, unsigned mult_interior=1, bool periodic=false)</td></tr>
<tr class="memdesc:ga9405b094225becc7fe4f7be65d1da933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a B-spline from an interval and knot vector specification.  <br /></td></tr>
<tr class="separator:ga9405b094225becc7fe4f7be65d1da933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc7ed57156cbc9486dd72877d51de642" id="r_gacc7ed57156cbc9486dd72877d51de642"><td class="memTemplParams" colspan="2">template&lt;typename T , typename KnotVectorType , typename Mat &gt; </td></tr>
<tr class="memitem:gacc7ed57156cbc9486dd72877d51de642"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Nurbs.html#gacc7ed57156cbc9486dd72877d51de642">gsTensorBoehm</a> (KnotVectorType &amp;knots, Mat &amp;coefs, T val, int <a class="el" href="namespacegismo.html#a799f686bf78453a7d21115f6a43aac2e">direction</a>, <a class="el" href="classgismo_1_1gsVector.html">gsVector</a>&lt; unsigned &gt; str, int r=1, bool update_knots=true)</td></tr>
<tr class="separator:gacc7ed57156cbc9486dd72877d51de642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2933f56d4708df22d2f958c1466d428c" id="r_ga2933f56d4708df22d2f958c1466d428c"><td class="memTemplParams" colspan="2">template&lt;typename KnotVectorType , typename Mat , typename ValIt &gt; </td></tr>
<tr class="memitem:ga2933f56d4708df22d2f958c1466d428c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Nurbs.html#ga2933f56d4708df22d2f958c1466d428c">gsTensorBoehmRefine</a> (KnotVectorType &amp;knots, Mat &amp;coefs, int <a class="el" href="namespacegismo.html#a799f686bf78453a7d21115f6a43aac2e">direction</a>, <a class="el" href="classgismo_1_1gsVector.html">gsVector</a>&lt; unsigned &gt; str, ValIt valBegin, ValIt valEnd, bool update_knots=true)</td></tr>
<tr class="separator:ga2933f56d4708df22d2f958c1466d428c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f4b94792ce51020c69197ec20192f31" id="r_ga9f4b94792ce51020c69197ec20192f31"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="gsConfig_8h.html#a368985810450e531ca9324d659d9e1e2">short_t</a> d, typename KnotVectorType , typename Mat , typename ValIt &gt; </td></tr>
<tr class="memitem:ga9f4b94792ce51020c69197ec20192f31"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Nurbs.html#ga9f4b94792ce51020c69197ec20192f31">gsTensorBoehmRefineLocal</a> (KnotVectorType &amp;knots, const unsigned index, Mat &amp;coefs, <a class="el" href="classgismo_1_1gsVector.html">gsVector</a>&lt; <a class="el" href="gsConfig_8h.html#ad722078677c063a09661059674fb996c">index_t</a>, d &gt; &amp;nmb_of_coefs, const <a class="el" href="classgismo_1_1gsVector.html">gsVector</a>&lt; <a class="el" href="gsConfig_8h.html#ad722078677c063a09661059674fb996c">index_t</a>, d &gt; &amp;act_size_of_coefs, const <a class="el" href="classgismo_1_1gsVector.html">gsVector</a>&lt; <a class="el" href="gsConfig_8h.html#ad722078677c063a09661059674fb996c">index_t</a>, d &gt; &amp;size_of_coefs, const unsigned <a class="el" href="namespacegismo.html#a799f686bf78453a7d21115f6a43aac2e">direction</a>, ValIt valBegin, ValIt valEnd, const bool update_knots)</td></tr>
<tr class="memdesc:ga9f4b94792ce51020c69197ec20192f31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Local refinement algorithm.  <br /></td></tr>
<tr class="separator:ga9f4b94792ce51020c69197ec20192f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97adb2318c3498278819a6d8047e3ebe" id="r_ga97adb2318c3498278819a6d8047e3ebe"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="gsConfig_8h.html#a368985810450e531ca9324d659d9e1e2">short_t</a> d, typename T , typename KnotVectorType , typename Mat &gt; </td></tr>
<tr class="memitem:ga97adb2318c3498278819a6d8047e3ebe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Nurbs.html#ga97adb2318c3498278819a6d8047e3ebe">gsTensorInsertKnotDegreeTimes</a> (const KnotVectorType &amp;knots, Mat &amp;coefs, const <a class="el" href="classgismo_1_1gsVector.html">gsVector</a>&lt; <a class="el" href="gsConfig_8h.html#ad722078677c063a09661059674fb996c">index_t</a>, d &gt; &amp;size_of_coefs, T val, const unsigned <a class="el" href="namespacegismo.html#a799f686bf78453a7d21115f6a43aac2e">direction</a>, <a class="el" href="classgismo_1_1gsVector.html">gsVector</a>&lt; <a class="el" href="gsConfig_8h.html#ad722078677c063a09661059674fb996c">index_t</a>, d &gt; &amp;start, <a class="el" href="classgismo_1_1gsVector.html">gsVector</a>&lt; <a class="el" href="gsConfig_8h.html#ad722078677c063a09661059674fb996c">index_t</a>, d &gt; &amp;end)</td></tr>
<tr class="memdesc:ga97adb2318c3498278819a6d8047e3ebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts knot <em>val</em> such that multiplicity of a <em>val</em> in knot vector is equal degree.  <br /></td></tr>
<tr class="separator:ga97adb2318c3498278819a6d8047e3ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8247df114b2e7f28f3e1cc87b5f2df5" id="r_gae8247df114b2e7f28f3e1cc87b5f2df5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Nurbs.html#gae8247df114b2e7f28f3e1cc87b5f2df5">refine</a> (<a class="el" href="classgismo_1_1gsMatrix.html">gsMatrix</a>&lt; T &gt; const &amp;boxes, int refExt=0)</td></tr>
<tr class="memdesc:gae8247df114b2e7f28f3e1cc87b5f2df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refinement of the tensor basis on the area defined by <em>boxes</em>.  <br /></td></tr>
<tr class="separator:gae8247df114b2e7f28f3e1cc87b5f2df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga0eaf1e5263fc56723f726f100517e78c" name="ga0eaf1e5263fc56723f726f100517e78c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0eaf1e5263fc56723f726f100517e78c">&#9670;&#160;</a></span>findHyperPlaneIntersections()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned findHyperPlaneIntersections </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgismo_1_1gsBSpline.html">gsBSpline</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgismo_1_1gsVector.html">gsVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>reference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Root&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>roots</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find intersections of a BSpline curve with an hyperplane </p>
<p>This function tries to be robust and to report correctly intersections of the curve with the given hyperplane of thickness 2*tolerance. Intersections are roots of a B-Spline curve and they can be of four types:</p>
<p>-odd points, i.e. the position with respect to the hyperplane changes at the intersection</p>
<p>-even points, i.e. the position with respect to the hyperplane is the same before and after the intersection</p>
<p>-odd intervals, i.e. the curve stays for a full parametric interval in the hyperplane and then exit on the other side of it</p>
<p>-even intervals, i.e. the curve stays for a full parametric interval in the hyperplane and then exit on the side it comes from</p>
<p>The intersections are reported as encountered while following the curve in the direction given by increasing parameter.</p>
<p>This function assumes an open knot vector: the first and last control points are in the curve. If the start or the end of the the curve is on the hyperplane it is reported as an odd intersection. This means that this special case must be handled outside of this function when used to determine if a point is inside a 2D area bounded by a closed curve. </p>

</div>
</div>
<a id="ga9405b094225becc7fe4f7be65d1da933" name="ga9405b094225becc7fe4f7be65d1da933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9405b094225becc7fe4f7be65d1da933">&#9670;&#160;</a></span>gsBSpline()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgismo_1_1gsBSpline.html">gsBSpline</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>u0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>u1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>interior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgismo_1_1gsMatrix.html">gsMatrix</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>coefs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>mult_interior</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>periodic</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a B-spline from an interval and knot vector specification. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u0</td><td>starting parameter </td></tr>
    <tr><td class="paramname">u1</td><td>end parameter </td></tr>
    <tr><td class="paramname">interior</td><td>number of interior knots </td></tr>
    <tr><td class="paramname">degree</td><td>degree of the spline space </td></tr>
    <tr><td class="paramname">coefs</td><td>coefficients of the spline space </td></tr>
    <tr><td class="paramname">mult_interior</td><td>multiplicity at the interior knots </td></tr>
    <tr><td class="paramname">periodic</td><td>specifies whether the B-spline is periodic </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacc7ed57156cbc9486dd72877d51de642" name="gacc7ed57156cbc9486dd72877d51de642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc7ed57156cbc9486dd72877d51de642">&#9670;&#160;</a></span>gsTensorBoehm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename KnotVectorType , typename Mat &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gsTensorBoehm </td>
          <td>(</td>
          <td class="paramtype">KnotVectorType &amp;&#160;</td>
          <td class="paramname"><em>knots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>coefs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgismo_1_1gsVector.html">gsVector</a>&lt; unsigned &gt;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>r</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>update_knots</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a knot insertion on knots and recomputes coefficients.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">knots</td><td>- vector of knots in direction "direction" </td></tr>
    <tr><td class="paramname">coefs</td><td>- coefficients (control points) </td></tr>
    <tr><td class="paramname">val</td><td>- value of a knot we will insert </td></tr>
    <tr><td class="paramname">direction</td><td>- in which direction (knot vector) we will insert knot </td></tr>
    <tr><td class="paramname">str</td><td>- vector of strides </td></tr>
    <tr><td class="paramname">r</td><td>- how many times we will insert knot </td></tr>
    <tr><td class="paramname">update_knots</td><td>- if we update knots or not </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2933f56d4708df22d2f958c1466d428c" name="ga2933f56d4708df22d2f958c1466d428c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2933f56d4708df22d2f958c1466d428c">&#9670;&#160;</a></span>gsTensorBoehmRefine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KnotVectorType , typename Mat , typename ValIt &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gsTensorBoehmRefine </td>
          <td>(</td>
          <td class="paramtype">KnotVectorType &amp;&#160;</td>
          <td class="paramname"><em>knots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>coefs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgismo_1_1gsVector.html">gsVector</a>&lt; unsigned &gt;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValIt&#160;</td>
          <td class="paramname"><em>valBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValIt&#160;</td>
          <td class="paramname"><em>valEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>update_knots</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a knot refinement and recomputes coefficients.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">knots</td><td>- knot vector in direction "direction" </td></tr>
    <tr><td class="paramname">coefs</td><td>- coefficients (control points) </td></tr>
    <tr><td class="paramname">direction</td><td>- in which direction we will refine knots </td></tr>
    <tr><td class="paramname">str</td><td>- vector of strides </td></tr>
    <tr><td class="paramname">valBegin</td><td>- iterator pointing to the begining of the vector of the knots we want to insert </td></tr>
    <tr><td class="paramname">valEnd</td><td>- iterator pointing to the end of the vector of the knots we want to insert </td></tr>
    <tr><td class="paramname">update_knots</td><td>- if we should update "knots" or not </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9f4b94792ce51020c69197ec20192f31" name="ga9f4b94792ce51020c69197ec20192f31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f4b94792ce51020c69197ec20192f31">&#9670;&#160;</a></span>gsTensorBoehmRefineLocal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="gsConfig_8h.html#a368985810450e531ca9324d659d9e1e2">short_t</a> d, typename KnotVectorType , typename Mat , typename ValIt &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gsTensorBoehmRefineLocal </td>
          <td>(</td>
          <td class="paramtype">KnotVectorType &amp;&#160;</td>
          <td class="paramname"><em>knots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>coefs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgismo_1_1gsVector.html">gsVector</a>&lt; <a class="el" href="gsConfig_8h.html#ad722078677c063a09661059674fb996c">index_t</a>, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>nmb_of_coefs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgismo_1_1gsVector.html">gsVector</a>&lt; <a class="el" href="gsConfig_8h.html#ad722078677c063a09661059674fb996c">index_t</a>, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>act_size_of_coefs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgismo_1_1gsVector.html">gsVector</a>&lt; <a class="el" href="gsConfig_8h.html#ad722078677c063a09661059674fb996c">index_t</a>, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>size_of_coefs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValIt&#160;</td>
          <td class="paramname"><em>valBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValIt&#160;</td>
          <td class="paramname"><em>valEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>update_knots</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Local refinement algorithm. </p>
<p>We refine given coefficients (coefs) in given direction with corresponding knots. Knots, we want to insert, can be accessed through iterators valBegin and valEnd. Index is index of the first basis function, in given direction, that corresponds to first coefficient in the coefs matrix. Through variable update_knots we can set if we want to add inserted knots into knot vector knots. Variables nmb_of_coefs, act_size_of_coefs and size_of_coefs describe coefs matrix.</p>
<p>We can use bigger coefs matrix than needed. Act_size_of_coefs describes actual size of the coefficients. (For example sizes of the edges of the cube that coefs matrix represents in 3D.) Size_of_coefs is size of the coefficients we will populate in this function call. Nmb_of_coefs presents number of nonzero coefficients in coefs matrix. </p>

</div>
</div>
<a id="ga97adb2318c3498278819a6d8047e3ebe" name="ga97adb2318c3498278819a6d8047e3ebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97adb2318c3498278819a6d8047e3ebe">&#9670;&#160;</a></span>gsTensorInsertKnotDegreeTimes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="gsConfig_8h.html#a368985810450e531ca9324d659d9e1e2">short_t</a> d, typename T , typename KnotVectorType , typename Mat &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gsTensorInsertKnotDegreeTimes </td>
          <td>(</td>
          <td class="paramtype">const KnotVectorType &amp;&#160;</td>
          <td class="paramname"><em>knots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>coefs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgismo_1_1gsVector.html">gsVector</a>&lt; <a class="el" href="gsConfig_8h.html#ad722078677c063a09661059674fb996c">index_t</a>, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>size_of_coefs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgismo_1_1gsVector.html">gsVector</a>&lt; <a class="el" href="gsConfig_8h.html#ad722078677c063a09661059674fb996c">index_t</a>, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgismo_1_1gsVector.html">gsVector</a>&lt; <a class="el" href="gsConfig_8h.html#ad722078677c063a09661059674fb996c">index_t</a>, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts knot <em>val</em> such that multiplicity of a <em>val</em> in knot vector is equal degree. </p>
<p>Function inserts the knot <em>val</em> into knot vector <em>knots</em>, such that multiplicity of <em>val</em> becomes <em>knots.degree()</em>. Given coefficients <em>coefs</em> must be local to the knot <em>val</em> (coefficients corresponding to the active base functions at <em>val</em>). <em>size_of_coefs</em> are sizes of the coefficients. <em>direction</em> is direction in which we perform a knot insertion. Sometimes we dont need to insert a knots at all rows at <em>direction</em>. With variables <em>start</em> and <em>end</em>, we can set subcube of the <em>coefs</em> where we will perform a knot insertion.</p>
<p>This function should just be used for evaluation via knot insertion (not the full coefficient matrix will be computed). </p>

</div>
</div>
<a id="gae8247df114b2e7f28f3e1cc87b5f2df5" name="gae8247df114b2e7f28f3e1cc87b5f2df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8247df114b2e7f28f3e1cc87b5f2df5">&#9670;&#160;</a></span>refine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="gsConfig_8h.html#a368985810450e531ca9324d659d9e1e2">short_t</a> d, class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void refine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgismo_1_1gsMatrix.html">gsMatrix</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>refExt</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Refinement of the tensor basis on the area defined by <em>boxes</em>. </p>
<p>Applies "local" refinement within the tensor-product structure of <a class="el" href="classgismo_1_1gsTensorBSplineBasis.html" title="A tensor product B-spline basis.">gsTensorBSplineBasis</a>. The areas for refinement are specified in <em>boxes</em>.<br  />
 <em>boxes</em> is a <a class="el" href="classgismo_1_1gsMatrix.html" title="A matrix with arbitrary coefficient type and fixed or dynamic size.">gsMatrix</a> of size <em>d</em> x <em>(2*N)</em>, where<br  />
 <em>d</em> is the dimension of the parameter domain and<br  />
 <em>N</em> is the number of refinement boxes.<br  />
 <br  />
 Every two successive columns in <em>boxes</em> correspond to the coordinates of the lower and upper corners of one refinement box, respectively (see example below). Note that a new knot will be inserted in every knot span contained in this area. If some of the given boxes overlap, the refinement will only be done once.</p>
<p><b>Example</b>, let </p><pre class="fragment">d = 2
knotvector1 = knotvector2 = [ 0 0 0  0.25  0.5  0.75  1 1 1 ]

boxes = [ 0.25  0.75  0     0.5 ]
[ 0     0.25  0.75  1   ]
</pre><p> The areas <em>[ 0.25, 0.75 ] x [ 0, 0.25 ]</em> and <em>[ 0, 0.5 ] x [ 0.75, 1 ]</em> will be refined. The knots <em>0.125</em>, <em>0.375</em>, and <em>0.625</em> will be inserted in <em>knotvector1</em>, and the knots <em>0.125</em> and <em>0.875</em> in <em>knotvector2</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">boxes</td><td><a class="el" href="classgismo_1_1gsMatrix.html" title="A matrix with arbitrary coefficient type and fixed or dynamic size.">gsMatrix</a> of size <em>d</em> x <em>(2*N)</em>; specifies areas for refinement.<br  />
 See above for details and format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">refExt</td><td>is ignored</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>NOTE This function directly modifies the basis (by inserting knots in the underlying univariate B-spline bases).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>: the <em>refExt</em> parameter is ignored in this implementation </dd></dl>

<p>Reimplemented from <a class="el" href="classgismo_1_1gsBasis.html#ae8247df114b2e7f28f3e1cc87b5f2df5">gsBasis&lt; T &gt;</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Jan 20 2025 09:35:27 for G+Smo by Doxygen v1.9.8 </li>
  </ul>
</div>
<!-- Piwik --> 
<!--
<script type="text/javascript">
var pkBaseURL = (("https:" == document.location.protocol) ? "https://stats.sylphide-consulting.com/piwik/" : "http://stats.sylphide-consulting.com/piwik/");
document.write(unescape("%3Cscript src='" + pkBaseURL + "piwik.js' type='text/javascript'%3E%3C/script%3E"));
</script><script type="text/javascript">
try {
var piwikTracker = Piwik.getTracker(pkBaseURL + "piwik.php", 20);
piwikTracker.trackPageView();
piwikTracker.enableLinkTracking();
} catch( err ) {}
</script><noscript><p><img src="http://stats.sylphide-consulting.com/piwik/piwik.php?idsite=20" style="border:0" alt="" /></p></noscript>
-->
<!-- End Piwik Tracking Code -->
</body>
</html>
