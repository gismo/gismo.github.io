<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<title>G+Smo: gsQuasiInterpolate&lt; T &gt; Struct Template Reference</title>
<link href="gismodoxy_tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://people.ricam.oeaw.ac.at/gismo/mj/MathJax.js"></script>
<link href="doxygen.css"   rel="stylesheet" type="text/css" />
<link href="gismodoxy.css" rel="stylesheet" type="text/css">
<!--  -->
<!-- <script type="text/javascript"> -->
<!-- </script> -->
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- <a name="top"></a> -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="gslogo-doxy.jpg"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname"><a href="index.html"><font style="font-variant:small-caps;">G+S</font><font style="font-variant:small-caps;"
															    color="#000000">mo</font></a>
   &#160;<span id="projectnumber">25.01.0</span>
   </div>
   <div id="projectbrief">Geometry + Simulation Modules</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('structgismo_1_1gsQuasiInterpolate.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="structgismo_1_1gsQuasiInterpolate-members.html">List of all members</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a>  </div>
  <div class="headertitle"><div class="title">gsQuasiInterpolate&lt; T &gt; Struct Template Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class T&gt;<br />
struct gismo::gsQuasiInterpolate&lt; T &gt;</div><p>Quasi-interpolation operators. </p>
<p>The struct <a class="el" href="structgismo_1_1gsQuasiInterpolate.html" title="Quasi-interpolation operators.">gsQuasiInterpolate</a> has three public member functions to use. These functions are implementations of different quasi interpolation methods, described in "Spline methods (Lyche
Morken)" <a class="el" href="citelist.html#CITEREF_splinemethods2008">[10]</a>. They take a function and approximate it via a B-Spline function, whose basis you have to provide. More details can be found in the description of the respective implementations and in <a class="el" href="citelist.html#CITEREF_splinemethods2008">[10]</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>coefficient type </td></tr>
  </table>
  </dd>
</dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a21b720457c45a2a75fe441ac61235839" id="r_a21b720457c45a2a75fe441ac61235839"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgismo_1_1gsQuasiInterpolate.html#a21b720457c45a2a75fe441ac61235839">EvalBased</a> (const <a class="el" href="classgismo_1_1gsBasis.html">gsBasis</a>&lt; T &gt; &amp;bb, const <a class="el" href="classgismo_1_1gsFunction.html">gsFunction</a>&lt; T &gt; &amp;fun, const bool specialCase, <a class="el" href="classgismo_1_1gsMatrix.html">gsMatrix</a>&lt; T &gt; &amp;result)</td></tr>
<tr class="memdesc:a21b720457c45a2a75fe441ac61235839"><td class="mdescLeft">&#160;</td><td class="mdescRight">A quasi-interpolation scheme based on the evaluation of the function at certain points. See sections 8.2.1, 8.2.2, 8.2.3 and Theorem 8.7 or Lemma 9.7 of "Spline methods (Lyche Morken)". The formulas for the special cases (degrees 1, 2 and 3) look like this:  <br /></td></tr>
<tr class="separator:a21b720457c45a2a75fe441ac61235839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ab50a7bade3750e0a76b23808a47ca" id="r_a40ab50a7bade3750e0a76b23808a47ca"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgismo_1_1gsQuasiInterpolate.html#a40ab50a7bade3750e0a76b23808a47ca">Schoenberg</a> (const <a class="el" href="classgismo_1_1gsBasis.html">gsBasis</a>&lt; T &gt; &amp;b, const <a class="el" href="classgismo_1_1gsFunction.html">gsFunction</a>&lt; T &gt; &amp;fun, <a class="el" href="classgismo_1_1gsMatrix.html">gsMatrix</a>&lt; T &gt; &amp;result)</td></tr>
<tr class="memdesc:a40ab50a7bade3750e0a76b23808a47ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">A quasi-interpolation scheme based on Schoenberg Variation Diminishing Spline Approximation. See Exercise 9.1 of "Spline methods (Lyche Morken)".  <br /></td></tr>
<tr class="separator:a40ab50a7bade3750e0a76b23808a47ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1c3ae8cc02b9c190e1a58afb143c397" id="r_af1c3ae8cc02b9c190e1a58afb143c397"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgismo_1_1gsQuasiInterpolate.html#af1c3ae8cc02b9c190e1a58afb143c397">Taylor</a> (const <a class="el" href="classgismo_1_1gsBasis.html">gsBasis</a>&lt; T &gt; &amp;bb, const <a class="el" href="classgismo_1_1gsFunction.html">gsFunction</a>&lt; T &gt; &amp;fun, const int &amp;r, <a class="el" href="classgismo_1_1gsMatrix.html">gsMatrix</a>&lt; T &gt; &amp;result)</td></tr>
<tr class="memdesc:af1c3ae8cc02b9c190e1a58afb143c397"><td class="mdescLeft">&#160;</td><td class="mdescRight">A quasi-interpolation scheme based on the tayor expansion of the function to approximate. See Theorem 8.5 of "Spline methods (Lyche Morken)" Theorem: (Lyche, Morken: Thm 8.5, page 178) Let \(p\) and \(\boldsymbol{\tau}\) be the degree and knotvector of the quasi-interpolant, respectively. Futhermore let \(r\) be an integer with \( 0 \le r \le p \) and let \(x_j\) be a number in \([\tau_j,
  \tau_{j+p+1}]\) for \(j=1,\dots,n\). Consider the quasi-interpolant.  <br /></td></tr>
<tr class="separator:af1c3ae8cc02b9c190e1a58afb143c397"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-methods" name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a278ff43aa5a32b1fbe1b982e48ab0010" id="r_a278ff43aa5a32b1fbe1b982e48ab0010"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classgismo_1_1gsMatrix.html">gsMatrix</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgismo_1_1gsQuasiInterpolate.html#a278ff43aa5a32b1fbe1b982e48ab0010">computeControlPoints</a> (const <a class="el" href="classgismo_1_1gsMatrix.html">gsMatrix</a>&lt; T &gt; &amp;weights, const <a class="el" href="classgismo_1_1gsFunction.html">gsFunction</a>&lt; T &gt; &amp;fun, const <a class="el" href="classgismo_1_1gsMatrix.html">gsMatrix</a>&lt; T &gt; &amp;xik)</td></tr>
<tr class="memdesc:a278ff43aa5a32b1fbe1b982e48ab0010"><td class="mdescLeft">&#160;</td><td class="mdescRight">The quasi-interpolant is a spline function, in particular a linear combination of some controlpoints and the B-spline basis functions. \(Q_p~f(x) = \sum\limits_{i=1}^n{\lambda_i(f)B_{i,p(x)}}\) where the controlpoints can be computed as \(\lambda_i(f) = \sum\limits_{k=0}^p{\omega_{i,k}f(x_i,k)}\). The points \(x_{i,k}\) are equally distributed points in the largest subinterval of \([\tau_{i+1}, \tau_{i+p}]\).  <br /></td></tr>
<tr class="separator:a278ff43aa5a32b1fbe1b982e48ab0010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3905797443a2015158d26ec2b05eb52" id="r_ae3905797443a2015158d26ec2b05eb52"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgismo_1_1gsQuasiInterpolate.html#ae3905797443a2015158d26ec2b05eb52">computeWeights</a> (const <a class="el" href="classgismo_1_1gsMatrix.html">gsMatrix</a>&lt; T &gt; &amp;points, const <a class="el" href="classgismo_1_1gsKnotVector.html">gsKnotVector</a>&lt; T &gt; &amp;knots, const int &amp;pos, <a class="el" href="classgismo_1_1gsMatrix.html">gsMatrix</a>&lt; T &gt; &amp;weights)</td></tr>
<tr class="memdesc:ae3905797443a2015158d26ec2b05eb52"><td class="mdescLeft">&#160;</td><td class="mdescRight">To compute the control points \( \lambda_i(f) = \sum\limits_{k=0}^p{\omega_{i,k}f(x_{i,k})} \) of the quasi-interpolant one uses the function computeControlPoints. The weights \( \omega_{i,k} \) can be computed as \(\omega_{i,k} = \gamma_i(p_{i,k})\), for \(k=0,1,\dots,p\), where.  <br /></td></tr>
<tr class="separator:ae3905797443a2015158d26ec2b05eb52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988d1f8dba666160dad1f0ffb57e257d" id="r_a988d1f8dba666160dad1f0ffb57e257d"><td class="memItemLeft" align="right" valign="top">static T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgismo_1_1gsQuasiInterpolate.html#a988d1f8dba666160dad1f0ffb57e257d">derivProd</a> (const std::vector&lt; T &gt; &amp;zeros, const int &amp;order, const T &amp;x)</td></tr>
<tr class="memdesc:a988d1f8dba666160dad1f0ffb57e257d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the derivative of a certain order of a normalized polynomial (leading coefficient is 1) defined by its roots at a given point. \(g(y) = (y-y_1) \cdots (y-y_n)\), where \(y_1,\dots,y_n\) are the roots of the polynomial.  <br /></td></tr>
<tr class="separator:a988d1f8dba666160dad1f0ffb57e257d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1968918541f023b3951b417161d6aa1" id="r_aa1968918541f023b3951b417161d6aa1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgismo_1_1gsQuasiInterpolate.html#aa1968918541f023b3951b417161d6aa1">distributePoints</a> (T a, T b, int n, <a class="el" href="classgismo_1_1gsMatrix.html">gsMatrix</a>&lt; T &gt; &amp;points)</td></tr>
<tr class="memdesc:aa1968918541f023b3951b417161d6aa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a number of equally distributed points in a given interval \([a,b]\). You get a list of points \(\{a, a+(b-a)\frac{1}{n-1}, \dots, a+(b-a)\frac{n-2}{n-1}, b\}\).  <br /></td></tr>
<tr class="separator:aa1968918541f023b3951b417161d6aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97b38f81c1d1570d541cb9174c56bf2" id="r_af97b38f81c1d1570d541cb9174c56bf2"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgismo_1_1gsQuasiInterpolate.html#af97b38f81c1d1570d541cb9174c56bf2">greatestSubInterval</a> (const <a class="el" href="classgismo_1_1gsKnotVector.html">gsKnotVector</a>&lt; T &gt; &amp;knots, const int &amp;posStart, const int &amp;posEnd)</td></tr>
<tr class="memdesc:af97b38f81c1d1570d541cb9174c56bf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function finds the greatest knot interval in a given range in a knot vector.  <br /></td></tr>
<tr class="separator:af97b38f81c1d1570d541cb9174c56bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a278ff43aa5a32b1fbe1b982e48ab0010" name="a278ff43aa5a32b1fbe1b982e48ab0010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a278ff43aa5a32b1fbe1b982e48ab0010">&#9670;&#160;</a></span>computeControlPoints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgismo_1_1gsMatrix.html">gsMatrix</a>&lt; T &gt; computeControlPoints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgismo_1_1gsMatrix.html">gsMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgismo_1_1gsFunction.html">gsFunction</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgismo_1_1gsMatrix.html">gsMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>xik</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The quasi-interpolant is a spline function, in particular a linear combination of some controlpoints and the B-spline basis functions. \(Q_p~f(x) = \sum\limits_{i=1}^n{\lambda_i(f)B_{i,p(x)}}\) where the controlpoints can be computed as \(\lambda_i(f) = \sum\limits_{k=0}^p{\omega_{i,k}f(x_i,k)}\). The points \(x_{i,k}\) are equally distributed points in the largest subinterval of \([\tau_{i+1}, \tau_{i+p}]\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">weights</td><td>the weights \(\omega_i,k\) of the above formula </td></tr>
    <tr><td class="paramname">fun</td><td>the function to approximate, \(f\) of the above formula </td></tr>
    <tr><td class="paramname">xik</td><td>the points \(x_{i,k}\) of the above formula </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the computed control point \(\lambda_i(f)\) </dd></dl>

</div>
</div>
<a id="ae3905797443a2015158d26ec2b05eb52" name="ae3905797443a2015158d26ec2b05eb52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3905797443a2015158d26ec2b05eb52">&#9670;&#160;</a></span>computeWeights()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void computeWeights </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgismo_1_1gsMatrix.html">gsMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgismo_1_1gsKnotVector.html">gsKnotVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>knots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgismo_1_1gsMatrix.html">gsMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>To compute the control points \( \lambda_i(f) = \sum\limits_{k=0}^p{\omega_{i,k}f(x_{i,k})} \) of the quasi-interpolant one uses the function computeControlPoints. The weights \( \omega_{i,k} \) can be computed as \(\omega_{i,k} = \gamma_i(p_{i,k})\), for \(k=0,1,\dots,p\), where. </p>
<p class="formulaDsp">
\[ \gamma_i(g) = \frac{1}{p!}\sum\limits_{(j_1,\dots,j_p)\in \mathcal{P}_p}{(\tau_{i+j_1}-v_1)\cdots(\tau_{i+j_p}-vp)},\]
</p>
<p> for a polynomial \(g(x) = (x-v_1) \cdots (x-v_p)\), where \(\mathcal{P}_p\) is the set of all permutations of the intergers \(\{1,2,\dots,p\}\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">points</td><td>the points \(x_{i,k}\) of the above formula </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">knots</td><td>the knotvector of the quasi-interpolant </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pos</td><td>the index i of the above formula </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">weights</td><td>the computed weights \(\omega_{i,k}\) of the above formula </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a988d1f8dba666160dad1f0ffb57e257d" name="a988d1f8dba666160dad1f0ffb57e257d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a988d1f8dba666160dad1f0ffb57e257d">&#9670;&#160;</a></span>derivProd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T derivProd </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>zeros</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the derivative of a certain order of a normalized polynomial (leading coefficient is 1) defined by its roots at a given point. \(g(y) = (y-y_1) \cdots (y-y_n)\), where \(y_1,\dots,y_n\) are the roots of the polynomial. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zeros</td><td>roots of the polynomial </td></tr>
    <tr><td class="paramname">order</td><td>the order of the derivative to compute </td></tr>
    <tr><td class="paramname">x</td><td>evaluation point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the derivative, at the given point, \(D^\alpha g(x)\), where \(\alpha\) is the given order. </dd></dl>

</div>
</div>
<a id="aa1968918541f023b3951b417161d6aa1" name="aa1968918541f023b3951b417161d6aa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1968918541f023b3951b417161d6aa1">&#9670;&#160;</a></span>distributePoints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void distributePoints </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgismo_1_1gsMatrix.html">gsMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a number of equally distributed points in a given interval \([a,b]\). You get a list of points \(\{a, a+(b-a)\frac{1}{n-1}, \dots, a+(b-a)\frac{n-2}{n-1}, b\}\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">a</td><td>start value of the interval </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">b</td><td>end value of the interval </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">n</td><td>number of points </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">computed</td><td>points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a21b720457c45a2a75fe441ac61235839" name="a21b720457c45a2a75fe441ac61235839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21b720457c45a2a75fe441ac61235839">&#9670;&#160;</a></span>EvalBased()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EvalBased </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgismo_1_1gsBasis.html">gsBasis</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>bb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgismo_1_1gsFunction.html">gsFunction</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>specialCase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgismo_1_1gsMatrix.html">gsMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A quasi-interpolation scheme based on the evaluation of the function at certain points. See sections 8.2.1, 8.2.2, 8.2.3 and Theorem 8.7 or Lemma 9.7 of "Spline methods (Lyche Morken)". The formulas for the special cases (degrees 1, 2 and 3) look like this: </p>
<p class="formulaDsp">
\[
P_{deg}~f(x) = \sum_{j=1}^n {\lambda_j(f) B_j(x)}
\]
</p>
<p> where the coefficients \( \lambda_j\) for \( j=1,\dots,n\) are given as:  </p><p class="formulaDsp">
\[
\lambda_j(f) = f(\tau_{j+1})
\]
</p>
<p> for degree 1,  </p><p class="formulaDsp">
\[
\lambda_j(f) = \begin{cases}
f(\tau_1) &amp;\mbox{if } j=1; \\
\frac{1}{2} (-f(x_{j,0}) + 4f(x_{j,1}) - f(x_{j,2}) ), &amp;\mbox{if } 1&lt;j&lt;n; \\
f(\tau_{n+1}) &amp;\mbox{if } j=n; \end{cases}
\]
</p>
<p> where \( x_{j,0} = \tau_{j+1}, \quad x_{j,1} = \frac{\tau_{j+1}+\tau_{j+2}}{2}, \quad x_{j,2} = \tau_{j+2} \)</p>
<p>for degree 2 and  </p><p class="formulaDsp">
\[
\lambda_j(f) = \begin{cases}
f(\tau_4) &amp;\mbox{if} j=1; \\
\frac{1}{18}(-5f(\tau_4)+40f(\tau_{9/2})-24f(\tau_5)+8f(\tau_{11/2})-f(\tau_6)) &amp;\mbox{if } j=2; \\
\frac{1}{6} (f(\tau_{j+1}) -8f(\tau_{j+3/2}) +20 f(\tau_{j+2}) -8f(\tau_{j+5/2})+f(\tau_{j+3})), &amp;\mbox{if } 2&lt;j&lt;n-1; \\
\frac{1}{18}(-f(\tau_{n-1})+8f(\tau_{n-1/2})-24f(\tau_n)+40f(\tau_{n+1/2})-5f(\tau_{n+1})) &amp;\mbox{if } j=n-1; \\
f(\tau_{n+1}) &amp;\mbox{if } j=n; \end{cases}
\]
</p>
<p> where \( \tau_{j+k/2} = \frac{\tau_{j+(k-1)/2}+\tau_{j+(k+1)/2}}{2} \),</p>
<p>for degree 3.</p>
<p>Theorem 8.7:</p>
<p>Let \( \mathbb{S}_{p,\mathbf{\tau}} \) be a spline space with a \(p+1\)-regular knot vector \( \tau = (\mathbf{\tau}_i)_{i=1}^{n+p+1} \). Let \( (x_{j,k})_{k=0}^r \) be \(r+1\) distinct points in \( [\tau_j,\tau_{j+p+1}] \) for \( j=1, \dots, n \) and let \(\omega_{j,k} \) be the j-th B-spline coefficient of the polynomial  </p><p class="formulaDsp">
\[
p_{j,k}(x) = \prod_{s=0, s\ne k}^r {\frac{x-x_{j,s}}{x_{j,k}-x_{j,s}}}.
\]
</p>
<p> Then \(P_{p,p}~f = f \) for all \( f \in \tau_r \) and if \(r=p\) and all the numbers \((x_{j,k})_{k=0}^r \) lie in one subinterval  </p><p class="formulaDsp">
\[
\tau_j \le \tau_{\ell_j} \le x_{j,0} &lt; x_{j,1} &lt; \cdots &lt; x_{j,r} \le \tau_{\ell_j +1} \le \tau_{j+p+1}
\]
</p>
<p> then \(P_{p,p}~f = f\) for all \( f \in \mathbb{S}_{p,\mathbf{\tau}} \). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>the B-spline basis of the interpolant (knots and degree) </td></tr>
    <tr><td class="paramname">fun</td><td>a function to approximate, </td></tr>
    <tr><td class="paramname">specialCase</td><td>if set to true, use the special implementations for degrees 1, 2 and 3; if set to false, use the general implementation </td></tr>
    <tr><td class="paramname">result</td><td>a B-spline function, that approximates the given function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af97b38f81c1d1570d541cb9174c56bf2" name="af97b38f81c1d1570d541cb9174c56bf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af97b38f81c1d1570d541cb9174c56bf2">&#9670;&#160;</a></span>greatestSubInterval()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int greatestSubInterval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgismo_1_1gsKnotVector.html">gsKnotVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>knots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>posStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>posEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function finds the greatest knot interval in a given range in a knot vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">knots</td><td>the knot vector </td></tr>
    <tr><td class="paramname">posStart</td><td>the index of the left knot of the first interval to be considered </td></tr>
    <tr><td class="paramname">posEnd</td><td>the index of the right knot of the last interval to be considers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the left knot of the largest knot interval </dd></dl>

</div>
</div>
<a id="a40ab50a7bade3750e0a76b23808a47ca" name="a40ab50a7bade3750e0a76b23808a47ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40ab50a7bade3750e0a76b23808a47ca">&#9670;&#160;</a></span>Schoenberg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Schoenberg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgismo_1_1gsBasis.html">gsBasis</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgismo_1_1gsFunction.html">gsFunction</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgismo_1_1gsMatrix.html">gsMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A quasi-interpolation scheme based on Schoenberg Variation Diminishing Spline Approximation. See Exercise 9.1 of "Spline methods (Lyche Morken)". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">b</td><td>the B-spline basis of the interpolant (knots and degree) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">fun</td><td>a function to approximate </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>a B-spline function, that approximates the given function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af1c3ae8cc02b9c190e1a58afb143c397" name="af1c3ae8cc02b9c190e1a58afb143c397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1c3ae8cc02b9c190e1a58afb143c397">&#9670;&#160;</a></span>Taylor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Taylor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgismo_1_1gsBasis.html">gsBasis</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>bb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgismo_1_1gsFunction.html">gsFunction</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgismo_1_1gsMatrix.html">gsMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A quasi-interpolation scheme based on the tayor expansion of the function to approximate. See Theorem 8.5 of "Spline methods (Lyche Morken)" Theorem: (Lyche, Morken: Thm 8.5, page 178) Let \(p\) and \(\boldsymbol{\tau}\) be the degree and knotvector of the quasi-interpolant, respectively. Futhermore let \(r\) be an integer with \( 0 \le r \le p \) and let \(x_j\) be a number in \([\tau_j,
  \tau_{j+p+1}]\) for \(j=1,\dots,n\). Consider the quasi-interpolant. </p>
<p class="formulaDsp">
\[
  Q_{p,r}~f=\sum\limits_{j=1}^n{\lambda_j(f)B_{j,p}}, \quad \text{where} \quad
  \lambda_j(f) = \frac{1}{p!}\sum\limits_{k=0}^r{(-1)^kD^{p-k}\rho_{j,p}(x_j)D^kf(x_j)}
  \]
</p>
<p> and \(\rho_{j,p}(y) = (y-\tau_{j+1}) \cdots (y - \tau_{j+p})\). Then \(Q_{p,r}\) reproduces all polynomials of degree \(r\) and \(Q_{p,p}\) reproduces all splines in \(\mathbb{S}_{p,\tau}\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">b</td><td>the B-spline basis of the interpolant (knots and degree) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">fun</td><td>a function to approximate </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">r</td><td>an integer in [0,deg] (order of maximal derivatives of the function) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>a B-spline function, that approximates the given function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacegismo.html">gismo</a></li><li class="navelem"><a class="el" href="structgismo_1_1gsQuasiInterpolate.html">gsQuasiInterpolate</a></li>
    <li class="footer">Generated on Mon Jan 20 2025 09:35:28 for G+Smo by Doxygen v1.9.8 </li>
  </ul>
</div>
<!-- Piwik --> 
<!--
<script type="text/javascript">
var pkBaseURL = (("https:" == document.location.protocol) ? "https://stats.sylphide-consulting.com/piwik/" : "http://stats.sylphide-consulting.com/piwik/");
document.write(unescape("%3Cscript src='" + pkBaseURL + "piwik.js' type='text/javascript'%3E%3C/script%3E"));
</script><script type="text/javascript">
try {
var piwikTracker = Piwik.getTracker(pkBaseURL + "piwik.php", 20);
piwikTracker.trackPageView();
piwikTracker.enableLinkTracking();
} catch( err ) {}
</script><noscript><p><img src="http://stats.sylphide-consulting.com/piwik/piwik.php?idsite=20" style="border:0" alt="" /></p></noscript>
-->
<!-- End Piwik Tracking Code -->
</body>
</html>
